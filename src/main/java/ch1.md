`Chater 1 p.28`

### 패턴의 4가지 요소

패턴 이름
- 패턴에 이름을 부여하는 것은 설계 어휘를 늘리는 일이며, 높은 수준의 추상화된 설계를 할 수 있도록 해 줍니다.
- 이름을 정의해 두면 문서에서 이 이름을 사용하여 설계의 `의도`를 표현할 수 있게 됩니다.
- 개발자들 간의 의사소통이 원활해집니다.

문제
- 언제 패턴을 사용하는가를 서술하며 해결할 문제와 그 배경을 설명합니다.
- 문제를 제시함으로써 패턴을 적용하는 것이 의미 있는 사례들을 정의하기도 합니다.

해법
- 설계를 구성한느 요소들과 그 요소들 간의 관계, 책임 그리고 협력 관계를 서술합니다.
- 구체적인 해결책이 이런 방법도 있다는 식의 해법

결과
- 디자인 패턴을 적용해서 얻는 결과와 장단점을 서술합니다.

> GoF의 디자인 패턴에서 말하는 디자인 패턴은 "특정한 전후 관계에서 일반적 설계 문제를 해결하기 위해 상호교류하는 수정 가능한 객체와 클래스들에 대한 설명"

 
## 디자인 패턴을 이용하여 문제를 푸는 방법

### 적당한 객체 찾기(p.40)
객체는 데이터와 이 데이터에 연산을 가하는 프로시저(procedure)를 함께 묶은 단위입니다.
프로시저를 일반적으로 **메서드**(method) 또는 **연산**(operation) 이라고 합니다.
객체는 **요청**(request) 또는 **메시지**(message)를 사용자에게 받으면 연산을 수행합니다.

요청은 객체가 연산을 실행하게 하는 유일한 방법이고, 연산은 객체의 내부 데이터의 상태를 변경하는 유일한 방법입니다.
이러한 접근의 제약 사항으로 객체의 내부 상태는 캡슐화(encapsulate)된다고 말합니다.
객체 외부에서는 객체의 내부 데이터에 직접 접근할 수 없고, 객체의 내부 데이터 표현 방법(데이터 타입 등)을 알 수 없습니다.

### 객체 인터페이스의 명세(p.41)
인터페이스 개념은 객체지향 시스템에서 가장 기본적인 것입니다. 객체는 인터페이스로 자신을 드러냅니다.
외부에서 객체를 알 수 있는 방법은 인터페이스 밖에 없기 때문에 인터페이스를 통해서만 처리를 요청할 수 있습니다.
객체의 인터페이스는 구현에 대해서는 전혀 알려주지 않습니다.
그러므로 서로 다른 객체는 인터페이스에 정의한 요청의 구현 방법을 자유롭게 선택할 수 있습니다.
이 의미는 동이한 인터페이스를 갖는 두 객체가 완전히 다른 구현ㅇ르 가질 수 있다는 것입니다.

어떤 요청과 그 요청을 처리할 객체를 프로그램 실행 중, 즉 런타임에 연결 짓는 것을 동적 바인딩(Dynamic binding)이라고 합니다.

동적 바인딩은 프로그램이 기대하는 객체를 동일한 인터페이스를 갖는 다른 객체로 대체할 수 있게 해줍니다.
이런 대체성을 우리는 다형성(Polymorphism)이라고 합니다.
다형성은 사용자의 정의를 단순화하고 객체 간의 결합도를 없애며, 프로그램 실행 중에는 서로 간의 관련성을 다양화할 수 있게 해 줍니다.

### 구현에 따르지 않고 ,인터페이스에 따르는 프로그래밍(p.48)
상속이 가진 다른 기능들 중에는 동일한 인터페이스를 갖는 객체군을 정의하는 것이 있는데, 매우 중요한 특징입니다.
객체군을 정의하는 것이 중요한 이유는 그것으로 다형성을 끌어낼 수 있기 때문입니다.

상속을 적절하게 이용하면, 모든 클래스는 추상 클래스를 상속하도록 하여 인터페이스를 공유할 수 있게 됩니다.
이것은 서브클래스가 단순히 연산을 추가하거나 재정의할뿐, 부모 클래스의 연산을 감추지 않는다는 뜻입니다.
모든 서브클래스들은 추상 클래스에 정의한 인터페이스를 처리할 수 있습니다.
다시 말해, 부모 클래스에 정의된 요청이 서브클래스에게 전달되어도 서브클래스는 이를 처리할 수 있다는 의미입니다.
이로써 모든서브 클래스들은 부모 클래스의 서브 타입이 되는 것입니다.

추상 클래스를 정의하고 인터페이스 개념으로 객체를 다룰 때 얻을 수 있는 두 가지 이점은 다음과 같습니다.
1. 사용자가 원하는 인터페이스를 그 객체가 만족하고 있는 한, 사용자는 그들이 사용하는 특정 객체 타입에 대해 알아야 할 필요는 없습니다.
2. 사용자는 이 객체들을 구현하는 클래스를 알 필요가 없고, 단지 인터페이스를 정의하는 추상 클래스가 무엇인지만 알면 됩니다.

> 구현이 아닌 인터페이스에 따라 프로그래밍합니다.

### 재사용을 실현 가능한 것으로(p.46)

#### 상속 대 합성(p.49)
객체지향 시스템에서 기능의 재사용을 위해 구사하는 가장 대표적인 기법은 클래스 상속, 그리고 객체 합성(object composition)입니다.
클래스 상속은 서브클래싱, 즉 다른 부모 클래스에서 상속받아 한 클래스의 구현을 정의하는 것입니다.
서브클래싱에 의한 재사용을 화이트박스 재사용(white-box reuse)이라고 합니다.
"화이트박스"는 내부를 볼 수 있다는 의미에서 나온 말입니다.
상속을 받으면 부모 클래스의 내부가 서브클래스에 공개되기 때문에 화이트박스인 셈입니다.

객체 합성은 클래스 상속에 대한 대안입니다.
다른 객체를 여러개 붙여서 새로운 기능 혹은 객체를 구성하는 것입니다.
객체를 합성하려면, 합성에 들어가는 객체들의 인터페이스를 명확하게 정의해 두어야 합니다.
이런 스타일의 재사용을 블랙박스 재사용(black-box reuse)이라고 하는데, 객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용되기 때문입니다.

**클래스 상속의 장단점**
- 컴파일 시점에 정적으로 정의되고 프로그래밍 언어가 직접 지원하므로 그대로 사용하면 됩니다.
- 클래스 상속으로 부모 클래스의 구현을 쉽게 수정할 수도 있는데, 서브클래스는 모든 연산이 아닌 일부만 재정의할 수도 있습니다.
- 런타임에 상속받은 부모 클래스의 구현을 변경할 수는 없습니다.
- 부모 클래스는 서브 클래스의 물리적 표현의 최소 부분만을 정의하기 때문에 서브클래스는 부모 클래스가 정의한 물리적 표현들을 전부 또는 일부 상속받습니다.
- 부모클래스의 구현에 종속될 수 밖에 없으므로, 부모의 변경은 서브클래스도 변경하게 만듭니다.
- 상속으로 부모를 모두 들어내기 때문에 캡슐화를 파괴한다는 주장도 있습니다.[Sny86]

**객체 합성의 장단점**
- 한 객체가 다른 객체에 대한 참조자를 얻는 바익으로 런타임에 동적으로 정의됩니다.
- 객체가 다른 객체의 인터페이스만을 바라보게 하기 때문에, 인터페이스 정의에 더 많은 주의를 기울여야 합니다.
- 객체는 인터페이스에서만 접근하므로 캡슐활르 유지할 수 있습니다.
- 동일 타입을 갖는다면 다른 객체로 런타임에 대체가 가능합니다.
- 객체는 인터페이스에 맞춰 구현되므로 구현 사이의 종속성은 확실히 줄어듭니다.
- 시스템 설계에 또다른 영향을 끼칩니다.
 
클래스 상속보다 객체 합성을 더 선호하는 이유는 각 클래스의 캡슈로하를 유지할 수 있고, 각 클래스의 한가지 작업에 집중할 수 있기 때문입니다.
클래스와 클래스 계층이 소규모로 유지되면서 통제 불능의 괴물로 자랄 가능성은 적습니다.
객체 합성으로 설계되면 클래스의 수는 적어지고 객체의 수는 좀더 많아질 수 있지만, 시스템의 행동은 클래스에 정의도니 정적인 내용보다는 런타임에 드러나는 객체 합성에 의한 상호 관련성에 따라 달라질 수 있습니다.

> 객체 합성이 클래스 합성(상속?)보다 더 나은 방법입니다.

상속과 객체 합성은 적절히 조합되어야 완벽한 재사용이 가능합니다.

#### 위임(p.51)
위임(delegation)은 합성을 상속만큼 강력하게 만드는 방법입니다.
위임에서는 두 객체가 하나의 요청을 처리합니다.
수신 객체가 연산의 처리를 위임자(delegate)에게 보냅니다.
이는 서브클래스가 부모 클래스에게 요청을 전달하는 것과 유사한 방식입니다.

위임의 가장 중요한 장점은 런타임에 행동의 복합을 가능하게 하고, 복합하는 방식도 변경해 준다는 것입니다.

위임이 갖는 단점은 객체 합성을 통해 소프트웨어 설계의 유연성을 보장하는 방법과 동일하게 동적인데다가 고도로 매개변수화된 소프트웨어는 정적인 소프트웨어 구조보다 이해하기가 더 어렵다는 것입니다.
그 이유는 클래스에 상호작용이 다 정의되어 있는 것이 아니라 런타임 객체에 따라서 그 결과가 다르기 때문입니다.
또한 런타임에 비효율적일 수 있습니다. 이런 위임이 만들어 내는 복잡함보다 단순화의 효괄르 더 크게 할 수 있다면 그 설계는 사용하기 좋은 설계입니다.

#### 상속 대 매개변수화된 타입(p.53)
기능의 재사용에 이용할 수 있는 다른 방법이 매개변수화된 타입(parameterized type)입니다.
Java 진영에서는 제네릭(generic)이라고합니다.
이 기법은 타입을 정의할 때 타입이 사용하는 다른 모든 타입을 다 지정하지 않은 채 정의합니다.
미리 정의하지 않은 타입은 매개변수로 제공합니다.
예를 들어, List 클래스는 내부에 포함할 원소들의 타입으로 매개변수화될 수 있습니다.
'즉, 매개변수로 타입을 지정한다.'(이하, 제네릭이라고 표기)

제네릭은 객체지향 시스템에서 행동을 복합할 수 있는 세 번째 방법입니다.

- 객체지향 시스템에서 행동을 복합할 수 있는 방법
  - 첫 번째, 클래스 상속
  - 두 번째, 객체 합성
  - 세 번째, 제네릭

#### 런타임 및 컴파일 타임의 구조를 관계짓기(p.54)
객체 관계 중에는 집합(aggregation)과 인지(acquaintance)라는 것이 있습니다.

집합은 한 객체가 다른 객체를 소유하거나 그것에 책임을 진다는 뜻입니다.
보통 우리는 한 객체가 다른 객체를 포함(having)한다거나 다른 객체의 부분(part of)이라고 말하죠.
객체 통합에는 통합된 객체 및 그 객체를 소유한 객체의 생존주기가 똑같다는 의미도 들어 있습니다.

객체 인지는 한 객체가 다른 객체에 대해 알고 있음(knows of)을 의미합니다.
이를 "연관(association)"관계 또는 "사용(using)"관계라고도 합니다.
인지를 받는 객체는 서로의 연산을 욫어할 수도 있지만 서로에 대해 책임은 지지 않습니다.
인지 관계는 통합 관계보다 관련성이 약해서 객체들 사이의 결합도가 약합니다.



